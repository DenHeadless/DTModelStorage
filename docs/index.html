<!DOCTYPE html>
<html lang="en">
  <head>
    <title>DTModelStorage  Reference</title>
    <link rel="stylesheet" type="text/css" href="css/jazzy.css" />
    <link rel="stylesheet" type="text/css" href="css/highlight.css" />
    <meta charset="utf-8">
    <script src="js/jquery.min.js" defer></script>
    <script src="js/jazzy.js" defer></script>
    
    <script src="js/lunr.min.js" defer></script>
    <script src="js/typeahead.jquery.js" defer></script>
    <script src="js/jazzy.search.js" defer></script>
  </head>
  <body>


    <a title="DTModelStorage  Reference"></a>

    <header class="header">
      <p class="header-col header-col--primary">
        <a class="header-link" href="index.html">
          DTModelStorage Docs
        </a>
         (88% documented)
      </p>
    
      <p class="header-col--secondary">
        <form role="search" action="search.json">
          <input type="text" placeholder="Search documentation" data-typeahead>
        </form>
      </p>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="https://github.com/DenTelezhkin/DTModelStorage">
            <img class="header-icon" src="img/gh.png"/>
            View on GitHub
          </a>
        </p>
    
        <p class="header-col header-col--secondary">
          <a class="header-link" href="dash-feed://https%3A%2F%2Fdentelezhkin%2Egithub%2Eio%2FDTModelStorage%2Fdocsets%2FDTModelStorage%2Exml">
            <img class="header-icon" src="img/dash.png"/>
            Install in Dash
          </a>
        </p>
    </header>

    <p class="breadcrumbs">
      <a class="breadcrumb" href="index.html">DTModelStorage Reference</a>
      <img class="carat" src="img/carat.png" />
      DTModelStorage  Reference
    </p>

    <div class="content-wrapper">
      <nav class="navigation">
        <ul class="nav-groups">
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Classes.html">Classes</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/BaseStorage.html">BaseStorage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/CoreDataStorage.html">CoreDataStorage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/EventReaction.html">EventReaction</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/FiveArgumentsEventReaction.html">FiveArgumentsEventReaction</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/FourArgumentsEventReaction.html">FourArgumentsEventReaction</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/MemoryStorage.html">MemoryStorage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/MemoryStorageAnomalyHandler.html">MemoryStorageAnomalyHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/SectionModel.html">SectionModel</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/SingleSectionEquatableStorage.html">SingleSectionEquatableStorage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/SingleSectionHashableStorage.html">SingleSectionHashableStorage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/SingleSectionStorage.html">SingleSectionStorage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/StorageUpdate.html">StorageUpdate</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Classes/ViewModelMapping.html">ViewModelMapping</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Global Variables.html">Global Variables</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global Variables.html#/DTCollectionViewElementSectionFooter">DTCollectionViewElementSectionFooter</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global Variables.html#/s:14DTModelStorage36DTCollectionViewElementSectionFooterSSvp">DTCollectionViewElementSectionFooter</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global Variables.html#/DTCollectionViewElementSectionHeader">DTCollectionViewElementSectionHeader</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global Variables.html#/s:14DTModelStorage36DTCollectionViewElementSectionHeaderSSvp">DTCollectionViewElementSectionHeader</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global Variables.html#/s:14DTModelStorage31DTTableViewElementSectionFooterSSvp">DTTableViewElementSectionFooter</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Global Variables.html#/s:14DTModelStorage31DTTableViewElementSectionHeaderSSvp">DTTableViewElementSectionHeader</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Enums.html">Enumerations</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/ChangeType.html">ChangeType</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/MappingCondition.html">MappingCondition</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/MemoryStorageAnomaly.html">MemoryStorageAnomaly</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/MemoryStorageError.html">MemoryStorageError</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/MemoryStorageError/InsertionReason.html">– InsertionReason</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/MemoryStorageError/BatchInsertionReason.html">– BatchInsertionReason</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/MemoryStorageError/SearchReason.html">– SearchReason</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/RuntimeHelper.html">RuntimeHelper</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/SingleSectionOperation.html">SingleSectionOperation</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Enums/ViewType.html">ViewType</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Extensions.html">Extensions</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/RangeReplaceableCollection.html">RangeReplaceableCollection</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/Sequence.html">Sequence</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Extensions/UINib.html">UINib</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Protocols.html">Protocols</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/AccumulationStrategy.html">AccumulationStrategy</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/AnomalyHandler.html">AnomalyHandler</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/EquatableDiffingAlgorithm.html">EquatableDiffingAlgorithm</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/HashableDiffingAlgorithm.html">HashableDiffingAlgorithm</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/HeaderFooterSettable.html">HeaderFooterSettable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/HeaderFooterStorage.html">HeaderFooterStorage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Identifiable.html">Identifiable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ModelTransfer.html">ModelTransfer</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Section.html">Section</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/SectionLocationIdentifyable.html">SectionLocationIdentifyable</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/Storage.html">Storage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/StorageUpdating.html">StorageUpdating</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/SupplementaryAccessible.html">SupplementaryAccessible</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/SupplementaryStorage.html">SupplementaryStorage</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Protocols/ViewModelMappingCustomizing.html">ViewModelMappingCustomizing</a>
              </li>
            </ul>
          </li>
          <li class="nav-group-name">
            <a class="nav-group-name-link" href="Structs.html">Structures</a>
            <ul class="nav-group-tasks">
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/AdditiveAccumulationStrategy.html">AdditiveAccumulationStrategy</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/DeleteOldValuesAccumulationStrategy.html">DeleteOldValuesAccumulationStrategy</a>
              </li>
              <li class="nav-group-task">
                <a class="nav-group-task-link" href="Structs/UpdateOldValuesAccumulationStrategy.html">UpdateOldValuesAccumulationStrategy</a>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
      <article class="main-content">

        <section class="section">
          <div class="section-content">
            
            <p><a href="https://travis-ci.org/DenTelezhkin/DTModelStorage"><img src="https://travis-ci.org/DenTelezhkin/DTModelStorage.svg?branch=master" alt="Build Status"></a>
<a href="http://codecov.io/github/DenTelezhkin/DTModelStorage?branch=master"><img src="http://codecov.io/github/DenTelezhkin/DTModelStorage/coverage.svg?branch=master" alt="codecov.io"></a>
<a href="https://cocoapods.org/pods/DTModelStorage"><img src="https://img.shields.io/cocoapods/v/DTModelStorage.svg" alt="CocoaPods compatible"></a>
<a href="https://github.com/Carthage/Carthage"><img src="https://img.shields.io/badge/Carthage-compatible-4BC51D.svg?style=flat" alt="Carthage compatible"></a>
<a href=""><img src="https://img.shields.io/packagist/l/doctrine/orm.svg" alt="Packagist"></a></p>
<h1 id='dtmodelstorage' class='heading'>DTModelStorage</h1>

<blockquote>
<p>This project is used as a dependency by <a href="https://github.com/DenTelezhkin/DTTableViewManager">DTTableViewManager</a> and <a href="https://github.com/DenTelezhkin/DTCollectionViewManager">DTCollectionViewManager</a> - great tools for UITableView and UICollectionView management.</p>
</blockquote>

<ul>
<li>[x] Support for any data structure - class, struct, enum, tuple</li>
<li>[x] Support for automatic diffing in section</li>
<li>[x] Protocol-oriented implementation with generic and associated types</li>
<li>[x] Powerful events system for storage consumers.</li>
<li>[x] High test coverage</li>
<li>[x] <a href="https://dentelezhkin.github.io/DTModelStorage/">Complete documentation</a></li>
</ul>
<h1 id='what-this-is-all-about' class='heading'>What this is all about?</h1>

<p>The goal of the project is to provide storage classes for datasource based controls. Let&rsquo;s take UITableView, for example. It&rsquo;s datasource methods mostly relates on following:</p>

<ul>
<li>sections</li>
<li>items in sections</li>
<li>section headers and footers</li>
</ul>

<p>Now, if we look on <code>UICollectionView</code>, that stuff does not change. And probably any kind of datasource based control can be adapted to use the same terminology. So, instead of reinventing the wheel every time, let&rsquo;s try to implement universal storage classes, that would fit any control.</p>

<p><code>DTModelStorage</code> supports 4 storage classes:</p>

<ul>
<li>Single section storage</li>
<li>Memory storage</li>
<li>CoreData storage</li>
<li>Realm storage</li>
</ul>

<p>Internal structure of these will be different, but we need a common interface and pattern to interact with them. This pattern is actually very simple, and contains two simple steps.</p>

<ol>
<li>Update storage</li>
<li>Notify delegate about changes in storage</li>
</ol>

<p>Memory storage classes will provide convenience methods to update storage, CoreData storage classes will rely on updates from <code>NSFetchedResultsControllerDelegate</code> protocol. So the first step will be different, but the second step stays the same. And delegate for storage classes will receive the same message, and it will not actually care, which storage is used. They will look the same from its point of view.</p>

<p><code>DTModelStorage</code> provides convenience methods to be used with <code>UITableView</code> or <code>UICollectionView</code>, but does not force any specific use, and does not imply, which UI components are compatible with it. However, storage classes are designed to work with <q>sections</q> and <q>items</q>, which generally means some kind of table or collection of items.</p>
<h1 id='singlesectionstorage' class='heading'>SingleSectionStorage</h1>

<p>While sometimes you need such fine-grained control, that <code><a href="Classes/MemoryStorage.html">MemoryStorage</a></code> provides, the most often use case for this library is just showing a collection of items, for example array of posts from social network, or search results with a single entity.</p>

<p>In this case, mostly used methods from <code><a href="Classes/MemoryStorage.html">MemoryStorage</a></code> are <code>setItems</code> and <code>addItems</code>, because in this case you probably don&rsquo;t need any other methods. What you may want, however, is an ability to automatically calculate diffs between old and new state to be able to animate UI without the need to call <code>reloadData</code>. That&rsquo;s where <code><a href="Classes/SingleSectionStorage.html">SingleSectionStorage</a></code> comes in.</p>

<p>But before showing any usage examples, let&rsquo;s talk about diffing a little bit. There are a lot of great collection differs outhere, and <code>DTModelStorage</code> is not aimed to providing another one. Instead, it provides an API to work with currently available differs.</p>
<h4 id='algorithms' class='heading'>Algorithms</h4>

<p>There are a lot of community-built algorithms to compute diff between two collections, for example here&rsquo;s list of frameworks that are built using Paul Heckel&rsquo;s <code>A Technique for Isolating Differences Between Files</code>:</p>

<ul>
<li><a href="https://github.com/mcudich/HeckelDiff">HeckelDiff</a></li>
<li><a href="https://github.com/lxcid/ListDiff">ListDiff</a> - port of <a href="https://github.com/Instagram/IGListKit">IGListKit&rsquo;s diffing algorithm</a> to Swift</li>
<li><a href="https://github.com/andre-alves/PHDiff">PHDiff</a></li>
</ul>

<p>There are other algorithms and implementations available, for example:</p>

<ul>
<li><a href="https://github.com/jflinter/Dwifft">Dwifft</a> - Longest common subsequence algorithm</li>
<li><a href="https://github.com/tonyarnold/Differ">Differ</a> - Longest common subsequence algorithm</li>
<li><a href="https://github.com/osteslag/Changeset">Changeset</a> - Wagner-Fischer algorithm (specific implementation of Levenstein algorithm).</li>
</ul>

<p>Because algorithms are built differently, but have some common traits, <code><a href="Classes/SingleSectionStorage.html">SingleSectionStorage</a></code> implements two concrete subclasses, that work with algorithms with <code>Equatable</code> elements and algorithms that work with <code>Hashable</code> elements - <code><a href="Classes/SingleSectionEquatableStorage.html">SingleSectionEquatableStorage</a></code> and <code><a href="Classes/SingleSectionHashableStorage.html">SingleSectionHashableStorage</a></code>.</p>
<h4 id='algorithm-adapter' class='heading'>Algorithm adapter</h4>

<p>To work with specific algorithm, you would need to create a thin adapter, that converts results of algorithm work to models, compatible with <code>DTModelStorage</code>. Here are some examples of how this can be done:</p>

<ul>
<li><a href="https://github.com/DenTelezhkin/DTModelStorage/blob/master/Tests/Specs/SingleSectionStorageTestCase.swift#L18-L30">Adapter for Dwifft</a></li>
<li><a href="https://github.com/DenTelezhkin/DTModelStorage/blob/master/Tests/Specs/SingleSectionStorageTestCase.swift#L32-L48">Adapter for HeckelDiff</a></li>
<li><a href="https://github.com/DenTelezhkin/DTTableViewManager/blob/master/Example/Example%20controllers/AutoDiffSearchViewController.swift#L14-L26">Adapter for Changeset</a></li>
</ul>
<h4 id='example' class='heading'>Example</h4>

<p>After adapter has been built, you need to implement <code><a href="Protocols/Identifiable.html">Identifiable</a></code> protocol on your data models to provide way to identify models:</p>
<pre class="highlight swift"><code><span class="kd">extension</span> <span class="kt">Post</span> <span class="p">:</span> <span class="kt">Identifiable</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">var</span> <span class="nv">identifier</span><span class="p">:</span> <span class="kt">AnyHashable</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>Create storage:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">storage</span> <span class="o">=</span> <span class="kt">SingleSectionEquatableStorage</span><span class="p">(</span><span class="nv">items</span><span class="p">:</span> <span class="n">arrayOfPosts</span><span class="p">,</span> <span class="nv">differ</span><span class="p">:</span> <span class="kt">ChangesetDiffer</span><span class="p">())</span>
</code></pre>

<p>Set new array of items and automatically calculate all diffs:</p>
<pre class="highlight swift"><code><span class="n">storage</span><span class="o">.</span><span class="nf">setItems</span><span class="p">(</span><span class="n">newPosts</span><span class="p">)</span>
</code></pre>

<p>Full example of automatically animating items in <code>UITableView</code> can be seen in <a href="https://github.com/DenTelezhkin/DTTableViewManager/blob/master/Example/Example%20controllers/AutoDiffSearchViewController.swift">DTTableViewManager repo</a></p>
<h4 id='adding-items' class='heading'>Adding items</h4>

<p>When you show list of items, common task is to add new loaded items to this list (for example load more content). Doing that is really simple:</p>
<pre class="highlight swift"><code><span class="n">storage</span><span class="o">.</span><span class="nf">addItems</span><span class="p">(</span><span class="n">newItems</span><span class="p">)</span>
</code></pre>

<p>Sometimes you may want to customize how items are accumulated in resulting collection of items. For example when content changed in time between first page request and second page request in load-more scenario. If back-end does not handle this for iOS side, you may want to build handling of such cases on client side. To do that, <code>DTModelStorage</code> provides  <code><a href="Protocols/AccumulationStrategy.html">AccumulationStrategy</a></code> protocol, that consists of single method:</p>
<pre class="highlight swift"><code><span class="kd">protocol</span> <span class="kt">AccumulationStrategy</span> <span class="p">{</span>
    <span class="kd">func</span> <span class="n">accumulate</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span><span class="kt">Identifiable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">oldItems</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">],</span> <span class="nv">newItems</span><span class="p">:</span> <span class="p">[</span><span class="kt">T</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">T</span><span class="p">]</span>
<span class="p">}</span>
</code></pre>

<p>This strategy determines how new collection of items will be formed. <code>DTModelStorage</code> provides three concrete implementations of this protocol:</p>

<ul>
<li><code><a href="Structs/AdditiveAccumulationStrategy.html">AdditiveAccumulationStrategy</a></code> - default strategy, that simply adds oldItems to newItemsArray.</li>
<li><code><a href="Structs/UpdateOldValuesAccumulationStrategy.html">UpdateOldValuesAccumulationStrategy</a></code> - replaces old values with new values from <code>newItems</code> array - uniqueness is determined by <code><a href="Protocols/Identifiable.html">Identifiable</a></code> <code>identifier</code> property</li>
<li><code><a href="Structs/DeleteOldValuesAccumulationStrategy.html">DeleteOldValuesAccumulationStrategy</a></code> - deletes old items, new values remain in new location as returned by <code>newArray</code> - uniqueness is determined by <code><a href="Protocols/Identifiable.html">Identifiable</a></code> <code>identifier</code> property.</li>
</ul>

<p>To use any of the strategies, just call <code>addItems</code> method with additional parameter:</p>
<pre class="highlight swift"><code><span class="n">storage</span><span class="o">.</span><span class="nf">addItems</span><span class="p">(</span><span class="n">newItems</span><span class="p">,</span> <span class="kt">UpdateOldValuesAccumulationStrategy</span><span class="p">())</span>
</code></pre>
<h4 id='several-model-types-in-singlesectionstorage' class='heading'>Several model types in SingleSectionStorage</h4>

<p><code><a href="Classes/SingleSectionStorage.html">SingleSectionStorage</a></code> class uses generics to determine it&rsquo;s item type. While it provides compile-time guarantees for item type, it unfortunately prevents using several model types in <code><a href="Classes/SingleSectionStorage.html">SingleSectionStorage</a></code> using <code>Any</code> type or a protocol. To do that, Swift needs to implement feature called <a href="https://github.com/apple/swift/blob/master/docs/GenericsManifesto.md#existentials">Generalized existentials</a>. Unfortunately, at the moment of writing (Xcode 10, Swift 4.2) this feature is not implemented.</p>

<p>Therefore, to support several data models type in <code>SingleSection</code> we can use technique called type-erasing. We can build generic wrapper class, that implements all protocols that are required, but actually accepts <code>Any</code> value:</p>
<pre class="highlight swift"><code><span class="kd">struct</span> <span class="kt">AnyIdentifiableEquatable</span><span class="p">:</span> <span class="kt">Identifiable</span><span class="p">,</span> <span class="kt">Equatable</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">value</span> <span class="p">:</span> <span class="kt">Any</span>
    <span class="k">let</span> <span class="nv">equals</span><span class="p">:</span> <span class="p">(</span><span class="kt">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="k">let</span> <span class="nv">identifier</span><span class="p">:</span> <span class="kt">AnyHashable</span>

    <span class="kd">init</span><span class="o">&lt;</span><span class="kt">T</span><span class="p">:</span><span class="kt">Identifiable</span> <span class="o">&amp;</span> <span class="kt">Equatable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">value</span><span class="p">:</span> <span class="kt">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">equals</span> <span class="o">=</span> <span class="p">{</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">instance</span> <span class="o">=</span> <span class="nv">$0</span> <span class="k">as?</span> <span class="kt">T</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="kc">false</span> <span class="p">}</span>
            <span class="k">return</span> <span class="n">instance</span> <span class="o">==</span> <span class="n">value</span>
        <span class="p">}</span>
        <span class="n">identifier</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">identifier</span>
    <span class="p">}</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="o">==</span> <span class="p">(</span><span class="nv">lhs</span><span class="p">:</span> <span class="kt">AnyIdentifiableEquatable</span><span class="p">,</span> <span class="nv">rhs</span><span class="p">:</span> <span class="kt">AnyIdentifiableEquatable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Bool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="o">.</span><span class="nf">equals</span><span class="p">(</span><span class="n">rhs</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">||</span> <span class="n">rhs</span><span class="o">.</span><span class="nf">equals</span><span class="p">(</span><span class="n">lhs</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>

<p>This way you can create a storage, that accepts any number of data models:</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">typeErasedInstances</span> <span class="o">=</span> <span class="p">[</span><span class="kt">AnyIdentifiableEquatable</span><span class="p">(</span><span class="kt">Foo</span><span class="p">()),</span> <span class="kt">AnyIdentifiableEquatable</span><span class="p">(</span><span class="kt">Bar</span><span class="p">())]</span>
<span class="k">let</span> <span class="nv">storage</span> <span class="o">=</span> <span class="kt">SingleSectionEquatableStorage</span><span class="p">(</span><span class="nv">items</span><span class="p">:</span> <span class="n">typeErasedInstances</span><span class="p">,</span> <span class="nv">differ</span><span class="p">:</span> <span class="kt">DwifftDiffer</span><span class="p">())</span>
</code></pre>

<p>Quite ugly, I know. But that seems like the only option that is possible today.</p>
<h4 id='supplementary-models-for-singlesection' class='heading'>Supplementary models for SingleSection</h4>

<p><code><a href="Classes/SingleSectionStorage.html">SingleSectionStorage</a></code> has support for supplementaries to support <code>UICollectionView</code> supplementary views, as well as <code>UITableView</code> headers and footers. The only difference from <code><a href="Classes/MemoryStorage.html">MemoryStorage</a></code> is that <code><a href="Classes/SingleSectionStorage.html">SingleSectionStorage</a></code> contains, you guessed it, only one section, and therefore one set of supplementaries.</p>
<h1 id='memorystorage' class='heading'>MemoryStorage</h1>

<p><code><a href="Classes/MemoryStorage.html">MemoryStorage</a></code> encapsulates storage of data models in memory. It&rsquo;s basically Array of <code><a href="Classes/SectionModel.html">SectionModel</a></code> items, which contain array of items for current section, and supplementary models of any kind, that add additional information for section. Good example would be UITableView headers and footers, or UICollectionView with UICollectionViewFlowLayout.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">storage</span> <span class="o">=</span> <span class="kt">MemoryStorage</span><span class="p">()</span>
</code></pre>
<h4 id='adding-items' class='heading'>Adding items</h4>
<pre class="highlight swift"><code><span class="n">storage</span><span class="o">.</span><span class="nf">addItem</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">storage</span><span class="o">.</span><span class="nf">addItem</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nv">toSection</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">storage</span><span class="o">.</span><span class="nf">addItems</span><span class="p">([</span><span class="n">model1</span><span class="p">,</span><span class="n">model2</span><span class="p">])</span>
<span class="n">storage</span><span class="o">.</span><span class="nf">addItems</span><span class="p">([</span><span class="n">model1</span><span class="p">,</span><span class="n">model2</span><span class="p">],</span> <span class="nv">toSection</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>

<span class="k">try</span><span class="p">?</span> <span class="n">storage</span><span class="o">.</span><span class="nf">insertItem</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="n">indexPath</span><span class="p">)</span>
</code></pre>
<h4 id='remove-replace-reload' class='heading'>Remove / replace / Reload</h4>
<pre class="highlight swift"><code><span class="k">try</span><span class="p">?</span> <span class="n">storage</span><span class="o">.</span><span class="nf">removeItem</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="n">storage</span><span class="o">.</span><span class="nf">removeItems</span><span class="p">([</span><span class="n">model1</span><span class="p">,</span><span class="n">model2</span><span class="p">])</span>
<span class="n">storage</span><span class="o">.</span><span class="nf">removeItems</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span><span class="n">indexPaths</span><span class="p">)</span>

<span class="k">try</span><span class="p">?</span> <span class="n">storage</span><span class="o">.</span><span class="nf">replaceItem</span><span class="p">(</span><span class="n">model1</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="n">model2</span><span class="p">)</span>

<span class="n">storage</span><span class="o">.</span><span class="nf">reloadItem</span><span class="p">(</span><span class="n">model1</span><span class="p">)</span>
</code></pre>
<h4 id='managing-sections' class='heading'>Managing sections</h4>
<pre class="highlight swift"><code><span class="n">storage</span><span class="o">.</span><span class="nf">deleteSections</span><span class="p">(</span><span class="kt">NSIndexSet</span><span class="p">(</span><span class="nv">index</span><span class="p">:</span> <span class="mi">1</span><span class="p">))</span>
</code></pre>
<h4 id='retrieving-items' class='heading'>Retrieving items</h4>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">item</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="nf">item</span><span class="p">(</span><span class="nv">at</span><span class="p">:</span><span class="kt">NSIndexPath</span><span class="p">(</span><span class="nv">forItem</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="nv">inSection</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">indexPath</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="nf">indexPath</span><span class="p">(</span><span class="nv">forItem</span><span class="p">:</span><span class="n">model</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">itemsInSection</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="nf">items</span><span class="p">(</span><span class="nv">inSection</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>

<span class="k">let</span> <span class="nv">section</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="nf">section</span><span class="p">(</span><span class="nv">atIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
</code></pre>
<h4 id='updating-manually' class='heading'>Updating manually</h4>

<p>Sometimes you may need to update batch of sections, remove all items, and add new ones. For those massive updates you don&rsquo;t actually need to update interface until update is finished. Wrap your updates in single block and pass it to updateWithoutAnimations method:</p>
<pre class="highlight swift"><code><span class="n">storage</span><span class="o">.</span><span class="n">updateWithoutAnimations</span> <span class="p">{</span>
    <span class="c1">// Add multiple rows, or another batch of edits</span>
<span class="p">}</span>
<span class="c1">// Calling reloadData is mandatory after calling this method. or you will get crash runtime</span>
</code></pre>

<p>For reordering of items, when animation is not needed, you can call <code>moveItemWithoutAnimation(from:to:)</code> method:</p>
<pre class="highlight swift"><code><span class="n">storage</span><span class="o">.</span><span class="nf">moveItemWithoutAnimation</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">sourceIndexPath</span><span class="p">,</span> <span class="nv">to</span><span class="p">:</span> <span class="n">destinationIndexPath</span><span class="p">)</span>
</code></pre>
<h4 id='supplementary-models' class='heading'>Supplementary models</h4>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">section</span> <span class="o">=</span> <span class="n">storage</span><span class="o">.</span><span class="nf">section</span><span class="p">(</span><span class="nv">atIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">)</span>
<span class="n">section</span><span class="o">.</span><span class="nf">setSupplementaryModel</span><span class="p">(</span><span class="s">"foo"</span><span class="p">,</span> <span class="nv">forKind</span><span class="p">:</span> <span class="kt">UICollectionElementKindSectionHeader</span><span class="p">)</span>
<span class="k">let</span> <span class="nv">model</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="nf">supplementaryModelOfKind</span><span class="p">(</span><span class="kt">UICollectionElementKindSectionHeader</span><span class="p">)</span>
</code></pre>
<h4 id='transferring-model' class='heading'>Transferring model</h4>

<p><code>DTModelStorage</code> defines <code><a href="Protocols/ModelTransfer.html">ModelTransfer</a></code> protocol, that allows transferring your data model to interested parties. This can be used for example for updating <code>UITableViewCell</code>. Thanks to associated <code>ModelType</code> of the protocol it is possible to transfer your model without any type casts.</p>
<h1 id='coredatastorage' class='heading'>CoreDataStorage</h1>

<p><code><a href="Classes/CoreDataStorage.html">CoreDataStorage</a></code> is meant to be used with <code>NSFetchedResultsController</code>. It automatically monitors all <code>NSFetchedResultsControllerDelegate</code> methods and and calls delegate with appropriate updates.</p>
<pre class="highlight swift"><code><span class="k">let</span> <span class="nv">storage</span> <span class="o">=</span> <span class="kt">CoreDataStorage</span><span class="p">(</span><span class="nv">fetchedResultsController</span><span class="p">:</span> <span class="n">controller</span><span class="p">)</span>
</code></pre>

<p>Any section in <code><a href="Classes/CoreDataStorage.html">CoreDataStorage</a></code> conform to <code>NSFetchedResultsSectionInfo</code> protocol, however <code>DTModelStorage</code> extends them to be <code><a href="Protocols/Section.html">Section</a></code> protocol compatible. This way CoreData sections and memory sections have the same interface.</p>

<p>For perfomance reasons, you should not retrieve items via <code>items</code> property, if you don&rsquo;t need to. Items may not be fetched from CoreData database, and if you need to retrieve only one specific item, it&rsquo;s better to call -<code>item(at:)</code> method instead. This way only one item will be actually fetched from database.</p>
<h2 id='realmstorage' class='heading'>RealmStorage</h2>

<p><code>RealmStorage</code> class is made to work with <a href="https://realm.io">realm.io</a> databases. It works with sections, that contain Realm.Results object.</p>

<p>Creating storage and filling it with results is very easy:</p>
<pre class="highlight plaintext"><code>let results = try! Realm().objects(Dog)

let storage = RealmStorage()
storage.addSection(with:results)
</code></pre>

<p>That&rsquo;s it! Results are automatically monitored, and refreshed, if Realm objects change.</p>
<h1 id='installation' class='heading'>Installation</h1>

<p><a href="https://cocoapods.org">CocoaPods</a>:</p>
<pre class="highlight plaintext"><code>pod 'DTModelStorage', '~&gt; 7.1'
</code></pre>

<p><a href="https://github.com/Carthage/Carthage">Carthage</a></p>
<pre class="highlight plaintext"><code>github "DenTelezhkin/DTModelStorage" ~&gt; 7.1
</code></pre>
<h1 id='requirements' class='heading'>Requirements</h1>

<ul>
<li>Xcode 10 and higher</li>
<li>Swift 4.1 and higher</li>
<li>iOS 8 and higher / tvOS 9.0 and higher</li>
</ul>
<h1 id='objective-c' class='heading'>Objective-C</h1>

<p>Due to generic implementation of DTModelStorage currently there are no plans to support Objective-C. If you want to use <code>DTModelStorage</code> in Objective-C project, you can use <a href="https://github.com/DenTelezhkin/DTModelStorage/releases/tag/1.3.1">latest compatible release</a> of the framework, that was previously written in Objective-C.</p>

          </div>
        </section>


      </article>
    </div>
    <section class="footer">
      <p>&copy; 2019 <a class="link" href="https://github.com/DenTelezhkin" target="_blank" rel="external">Denys Telezhkin</a>. All rights reserved. (Last updated: 2019-06-17)</p>
      <p>Generated by <a class="link" href="https://github.com/realm/jazzy" target="_blank" rel="external">jazzy ♪♫ v0.9.4</a>, a <a class="link" href="https://realm.io" target="_blank" rel="external">Realm</a> project.</p>
    </section>
  </body>
</div>
</html>
